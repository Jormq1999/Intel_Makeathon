# Integration Guide: Generating and Integrating UVM Components

## Overview

This guide describes how to integrate extracted verification components (sequences, signals, architecture) into a working UVM test environment. It covers the full workflow, from analyzing the required change to generating and integrating the necessary UVM components and finally creating a runnable test.

---

## Part 1: Integration Strategy & Workflow

### 1.1. Change Impact Analysis: Minor vs. Major

To optimize the workflow, the agent must first determine if a request represents a **major change** (requiring new component generation) or a **minor change** (which can be applied to existing components).

-   **Minor Change**: Modifications to existing sequences, parameter adjustments, adding constraints, or simple checks in a scoreboard.
    -   *Keywords*: "Modify sequence," "Adjust timing," "Add constraint," "Update test."
    -   **Workflow**: For minor changes, the agent should locate the target file and apply the change surgically, leaving the rest of the file untouched.

-   **Major Change**: Introduction of a new protocol, a new UVM agent, or significant architectural redesigns.
    -   *Keywords*: "New protocol," "Create agent," "Redesign scoreboard."
    -   **Workflow**: For major changes, the agent should follow the full generative path outlined below.

### 1.2. Generative Integration Workflow

For major changes, the agent should follow a structured, generative process.

```mermaid
graph TD
    A[1. Extracted Components] --> B[2. Analyze & Plan Integration];
    B --> C[3. Search for Reusable Assets];
    C --> D[4. Generate Components];
    D --> D1[UVM Interface];
    D --> D2[Transaction Class];
    D --> D3[Agent (Driver, Monitor, Sequencer)];
    D --> D4[Environment];
    
    D --> E[5. Integrate & Assemble Test];
    E --> E1[Create Virtual Sequence];
    E1 --> E2[Create Base Test];
    E2 --> E3[Update Build System];
    
    E3 --> F[6. Working Test];
```

### 1.3. Reference Component Search (Step 3)

Before generating code, the agent **must** search the workspace for existing verification assets that can be reused or adapted. This promotes code reuse and stability.

-   **Search Strategy**: Use keywords from the extracted data (e.g., protocol names like `AXI`, `USB`, component types like `driver`, `monitor`).
-   **File Types**: Focus on `.sv`, `.svh`, `*_pkg.sv`, and `*_test.sv`.
-   **Analysis**: If relevant files are found, analyze them to determine if they can be used as a template or included directly.

---

## Part 2: A Practical Integration Plan (Case Study: `ip-csme`)

This section provides a concrete plan for integrating an AI-generated test into the `ip-csme` repository.

### 2.1. Create the New Test File

-   **Location**: `verif/csme_usbr/tests/`
-   **Action**: Create a new test file (e.g., `moa_usbr_ai_generated_test.sv`) that extends the project's base test (`usbr_base_test`). This test will be responsible for starting the top-level sequence generated by the agent.

    ```systemverilog
    // In moa_usbr_ai_generated_test.sv
    class moa_usbr_ai_generated_test extends usbr_base_test;
      `uvm_component_utils(moa_usbr_ai_generated_test)

      // The top-level sequence that the AI agent will generate
      ai_generated_top_seq m_seq;

      function new(string name, uvm_component parent);
        super.new(name, parent);
      endfunction

      virtual task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        // Create and start the generated sequence on the virtual sequencer
        m_seq = ai_generated_top_seq::type_id::create("m_seq");
        m_seq.start(m_env.m_vsequencer);
        phase.drop_objection(this);
      endtask
    endclass
    ```

### 2.2. Define the Generated Sequence

-   **Location**: `verif/csme_usbr/env/seqlib/`
-   **Action**: The agent should place the newly generated sequence in a file like `ai_generated_top_seq.sv`. This sequence should extend the project's base sequence (`moa_usbr_base_seq`) and will contain the core stimulus logic.

    ```systemverilog
    // In ai_generated_top_seq.sv
    class ai_generated_top_seq extends moa_usbr_base_seq;
      `uvm_object_utils(ai_generated_top_seq)

      // Handles for other sequences to be executed
      csme_usbr_init_seq m_init_seq;
      csme_usbr_bulk_data_seq m_bulk_seq;

      function new(string name = "ai_generated_top_seq");
        super.new(name);
      endfunction

      virtual task body();
        // The agent will generate the stimulus orchestration here.
        // Example:
        `uvm_do(m_init_seq)
        `uvm_do_with(m_bulk_seq, { num_packets == 10; })
      endtask
    endclass
    ```

### 2.3. Update the Build System

-   **Location**: `verif/csme_usbr/tests/testlists/`
-   **Action**: To make the simulator aware of the new test, the agent must add the path to the new test file (`moa_usbr_ai_generated_test.sv`) and the new sequence file (`ai_generated_top_seq.sv`) to the appropriate build lists.
    -   Add the test to a test list file (e.g., `all.list`).
    -   Add the sequence to a source file list (e.g., a `.f` file).

    ```
    // Example for a test list file
    $(TEST_DIR)/moa_usbr_ai_generated_test.sv
    ```

### 2.4. Run the Test

-   **Execution**: The test can be run using the existing simulation flow by specifying the new test name as the `UVM_TESTNAME`.
    -   `... +UVM_TESTNAME=moa_usbr_ai_generated_test`

---

## Part 3: UVM Component Generation Templates

### 3.1. UVM Interface Template

This template generates a standard UVM interface with clocking blocks and modports.

```systemverilog
interface {interface_name}_if (input logic clk, input logic rst_n);
  // Signal declarations
{%- for signal in signals %}
  logic {% if signal.width > 1 %}[{{ signal.width-1 }}:0] {% endif %}{{ signal.name }};
{%- endfor %}
  
  // Driver and Monitor clocking blocks
  clocking driver_cb @(posedge clk);
    default input #1step output #1ns;
{%- for signal in signals if signal.direction == 'output' %}
    output {{ signal.name }};
{%- endfor %}
  endclocking
  
  clocking monitor_cb @(posedge clk);
    default input #1step;
{%- for signal in signals %}
    input {{ signal.name }};
{%- endfor %}
  endclocking
  
  // Modports for DUT, driver, and monitor
  modport driver_mp(clocking driver_cb, input clk, input rst_n);
  modport monitor_mp(clocking monitor_cb, input clk, input rst_n);
endinterface
```

### 3.2. Agent Configuration Template

This template creates a configuration object for a UVM agent, including its activity level and a virtual interface handle.

```systemverilog
class {agent_name}_config extends uvm_object;
  `uvm_object_utils({agent_name}_config)
  
  uvm_active_passive_enum is_active = UVM_ACTIVE;
  virtual {interface_name}_if vif;
  
  function new(string name = "{agent_name}_config");
    super.new(name);
  endfunction
endclass
```

### 3.3. Environment Assembly Template

This template shows how to construct a UVM environment, creating and connecting agents and other components like scoreboards.

```systemverilog
class {test_name}_env extends uvm_env;
  `uvm_component_utils({test_name}_env)
  
  // Agent and scoreboard instances
  {agent_name} m_agent;
  {scoreboard_name} m_scoreboard;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    m_agent = {agent_name}::type_id::create("m_agent", this);
    m_scoreboard = {scoreboard_name}::type_id::create("m_scoreboard", this);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    // Connect analysis ports from agent's monitor to scoreboard
    m_agent.ap.connect(m_scoreboard.analysis_export);
  endfunction
endclass
```
